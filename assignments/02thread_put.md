unagi_serverのスレッド用いた安全な並列化
====================

課題1 では get, getcなど, データの更新を伴わない処理を並行に実行できるようにした. しかしながらこの変更は, putリクエストも並行に処理してしまうので, 並行にやってくるリクエストの中に putが含まれていると正しく動作しない.

(必須) 課題 2-1
====================

適切な排他制御を行って, get, getc, put, putc, dump, dumpcリクエストがどんなタイミングでやってきても正しく処理できるようにせよ.

概要説明
--------------------

授業で説明したとおり, 共有データが複数のスレッドによって並行にアクセスされ, かつそのうちの少なくともひとつがデータの書き換えを行っている場合, **たいがいの場合**そのままでは上手く動かない. unagi_serverももちろん例外ではない. 具体的にはすべてのリクエストは文書を格納しているデータ構造を参照する. 具体的には以下の run_server 関数

```
static void run_server(cmdline_options_t opt) {
  server_t * sv = start_server(opt);


}
```

の先頭で作られたserver_t sv で参照されるデータ構造から参照される
sv->repo (レポジトリ)というデータ構造がドキュメントのレポジトリである.

このデータ構造が複数のスレッドからアクセスされても壊れないようにすることが目標である.

 * 方法1: Pthreadのmutex (pthread_mutex_t) を使う
 * 方法2: Pthreadのreader write lock (pthread_rwlock_t)を使う

答えの確かめ方
--------------------

課題1とほぼ同様

 1. メッセージを作る
```
$ make -f random_test.mk n_puts=... n_gets=... prepare [ -j ... ]
```
n_puts, n_getsは適宜調整. -j の引数(並行して生成するファイル数)も適宜調整

 2. サーバを立ち上げる
```
$ ./unagi_server -l ""
server listening on port 35341
```
 3. putとgetを並行に実行する
```
$ time make -f random_test.mk port=35341 n_puts=... n_gets=... put_get -j 100
```
n_puts, n_getsは1.と同じものを指定.
-j 100は同時に立ち上がるクライアント数の上限. ある程度大きくする.
 4. 結果確認
課題1と同様, status/g_* というファイル中の'OK 1'と'OK 0'を数え, n_putsで指定したのと同じだけの'OK 1', (n_gets - n_puts)と同じだけの'OK 0'が現れていたら(恐らく)正解. たとえば, n_puts=200, n_gets=300で実験したのであれば,
```
$ grep 'OK 1' status/g_* | wc
    200     400    3492
$ grep 'OK 0' status/g_* | wc
    100     200    1800
```

性能の測定
--------------------

上記のステップ2で, 内部が並列(スレッド)化されている場合とされていない場合の両方でステップ3を実行して比較せよ. 課題1と同様, その間のCPU利用量やメモリ使用量を観測せよ.

提出物
====================
 * ソースコード(追加, 変更全てをcommit, push)
 * 以下を含む内容のテキストファイル submit/02submit.md (add, commit, push)
  1. 達成した課題の番号
  1. スレッドなし・ありの場合の性能比較をまとめたもの
  1. 動作確認と性能測定を行った際の実行ログ. スレッド化した場合としていない場合
  
  